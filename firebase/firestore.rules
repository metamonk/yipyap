rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection - authenticated users can read any profile, but only write their own
    match /users/{userId} {
      // Authenticated users can read any user profile (needed for search, conversations, chat UI)
      allow read: if request.auth != null;

      // Users can create their own profile with all required fields
      allow create: if request.auth != null &&
                      request.auth.uid == userId &&
                      // Validate required fields exist for new documents
                      request.resource.data.keys().hasAll(['uid', 'username', 'displayName', 'email', 'presence', 'settings', 'createdAt', 'updatedAt']) &&
                      // Validate uid matches authenticated user
                      request.resource.data.uid == request.auth.uid &&
                      // Validate username format and length (3-20 chars, lowercase alphanumeric + underscore)
                      request.resource.data.username is string &&
                      request.resource.data.username.size() >= 3 &&
                      request.resource.data.username.size() <= 20 &&
                      request.resource.data.username.matches('^[a-z0-9_]+$') &&
                      // Validate displayName length (1-50 chars)
                      request.resource.data.displayName is string &&
                      request.resource.data.displayName.size() >= 1 &&
                      request.resource.data.displayName.size() <= 50 &&
                      // Validate email is a string
                      request.resource.data.email is string &&
                      request.resource.data.email.size() > 0 &&
                      // Validate presence object structure
                      request.resource.data.presence is map &&
                      request.resource.data.presence.keys().hasAll(['status', 'lastSeen']) &&
                      request.resource.data.presence.status in ['online', 'offline'] &&
                      request.resource.data.presence.lastSeen is timestamp &&
                      // Validate settings object structure
                      request.resource.data.settings is map &&
                      request.resource.data.settings.keys().hasAll(['sendReadReceipts', 'notificationsEnabled']) &&
                      request.resource.data.settings.sendReadReceipts is bool &&
                      request.resource.data.settings.notificationsEnabled is bool &&
                      // Validate timestamps
                      request.resource.data.createdAt is timestamp &&
                      request.resource.data.updatedAt is timestamp &&
                      // Optional fields validation (if present)
                      (!request.resource.data.keys().hasAny(['photoURL']) || request.resource.data.photoURL is string) &&
                      (!request.resource.data.keys().hasAny(['fcmToken']) || request.resource.data.fcmToken is string);

      // Users can update their own profile - allow partial updates
      allow update: if request.auth != null &&
                      request.auth.uid == userId &&
                      // Validate uid cannot be changed
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid']) || request.resource.data.uid == request.auth.uid) &&
                      // If updating username, validate format
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['username']) ||
                       (request.resource.data.username is string &&
                        request.resource.data.username.size() >= 3 &&
                        request.resource.data.username.size() <= 20 &&
                        request.resource.data.username.matches('^[a-z0-9_]+$'))) &&
                      // If updating displayName, validate length
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['displayName']) ||
                       (request.resource.data.displayName is string &&
                        request.resource.data.displayName.size() >= 1 &&
                        request.resource.data.displayName.size() <= 50)) &&
                      // If updating email, validate it's a string
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['email']) ||
                       (request.resource.data.email is string && request.resource.data.email.size() > 0)) &&
                      // If updating presence, validate structure
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['presence']) ||
                       (request.resource.data.presence is map &&
                        (!request.resource.data.presence.keys().hasAny(['status']) || request.resource.data.presence.status in ['online', 'offline']) &&
                        (!request.resource.data.presence.keys().hasAny(['lastSeen']) || request.resource.data.presence.lastSeen is timestamp))) &&
                      // If updating settings, validate structure
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['settings']) ||
                       (request.resource.data.settings is map &&
                        (!request.resource.data.settings.keys().hasAny(['sendReadReceipts']) || request.resource.data.settings.sendReadReceipts is bool) &&
                        (!request.resource.data.settings.keys().hasAny(['notificationsEnabled']) || request.resource.data.settings.notificationsEnabled is bool))) &&
                      // Validate timestamps if present
                      (!request.resource.data.keys().hasAny(['createdAt']) || request.resource.data.createdAt is timestamp) &&
                      (!request.resource.data.keys().hasAny(['updatedAt']) || request.resource.data.updatedAt is timestamp) &&
                      // Validate optional fields if present
                      (!request.resource.data.keys().hasAny(['photoURL']) || request.resource.data.photoURL is string) &&
                      (!request.resource.data.keys().hasAny(['fcmToken']) || request.resource.data.fcmToken is string);
    }

    // Username uniqueness collection
    match /usernames/{username} {
      // Anyone can read usernames to check availability (usernames are public identifiers)
      allow read: if true;

      // Users can only create their own username claim
      // The uid in the document must match the authenticated user
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.uid;

      // Prevent deletion or update of username claims
      // Usernames are permanent once created
      allow update, delete: if false;
    }

    // Conversations - users can access if they're participants
    match /conversations/{conversationId} {
      // Helper function to check if user is a participant
      function isParticipant() {
        return request.auth != null &&
               request.auth.uid in resource.data.participantIds;
      }

      function isParticipantInNewDoc() {
        return request.auth != null &&
               request.auth.uid in request.resource.data.participantIds;
      }

      // Helper function to check if user ID is in the deterministic conversation ID
      // For direct conversations, ID format is "userId1_userId2" (sorted alphabetically)
      function isInConversationId() {
        return request.auth != null && (
          // ID starts with user's ID followed by underscore
          conversationId.matches('^' + request.auth.uid + '_.*') ||
          // ID ends with underscore followed by user's ID
          conversationId.matches('.*_' + request.auth.uid + '$')
        );
      }

      // Read: Allow authenticated users to read conversations they're participants of
      // This rule works with queries that filter by participantIds array-contains
      allow read: if request.auth != null && (
        // For queries (list operations), Firestore will verify this after applying the query filter
        // The query filter ensures only conversations with the user in participantIds are returned
        request.auth.uid in resource.data.participantIds ||
        // For single document reads on non-existent docs (existence checks for direct conversations)
        (resource == null && isInConversationId())
      );

      // Create: User must include themselves in participantIds and limit group size
      allow create: if isParticipantInNewDoc() &&
                       request.resource.data.participantIds.size() <= 10;

      // Update: User must be a participant
      allow update: if isParticipant();

      // Delete: Not allowed (use soft delete via deletedBy field)
      allow delete: if false;

      // Messages within conversations
      match /messages/{messageId} {
        // Helper function to get parent conversation
        function getConversation() {
          return get(/databases/$(database)/documents/conversations/$(conversationId)).data;
        }

        function isConversationParticipant() {
          return request.auth != null &&
                 request.auth.uid in getConversation().participantIds;
        }

        // Read: User must be participant in parent conversation
        allow read: if isConversationParticipant();

        // Create: User must be participant AND senderId must match auth.uid
        allow create: if isConversationParticipant() &&
                         request.auth.uid == request.resource.data.senderId;

        // Update: User must be participant (for read receipts, status updates)
        allow update: if isConversationParticipant();

        // Delete: Not allowed (messages are immutable)
        allow delete: if false;
      }
    }

    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
