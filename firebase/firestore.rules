rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Users collection - authenticated users can read any profile, but only write their own
    match /users/{userId} {
      // Authenticated users can read any user profile (needed for search, conversations, chat UI)
      allow read: if request.auth != null;

      // Users can create their own profile with all required fields
      allow create: if request.auth != null &&
                      request.auth.uid == userId &&
                      // Validate required fields exist for new documents
                      request.resource.data.keys().hasAll(['uid', 'username', 'displayName', 'email', 'presence', 'settings', 'createdAt', 'updatedAt']) &&
                      // Validate uid matches authenticated user
                      request.resource.data.uid == request.auth.uid &&
                      // Validate username format and length (3-20 chars, lowercase alphanumeric + underscore)
                      request.resource.data.username is string &&
                      request.resource.data.username.size() >= 3 &&
                      request.resource.data.username.size() <= 20 &&
                      request.resource.data.username.matches('^[a-z0-9_]+$') &&
                      // Validate displayName length (1-50 chars)
                      request.resource.data.displayName is string &&
                      request.resource.data.displayName.size() >= 1 &&
                      request.resource.data.displayName.size() <= 50 &&
                      // Validate email is a string
                      request.resource.data.email is string &&
                      request.resource.data.email.size() > 0 &&
                      // Validate presence object structure
                      request.resource.data.presence is map &&
                      request.resource.data.presence.keys().hasAll(['status', 'lastSeen']) &&
                      request.resource.data.presence.status in ['online', 'offline'] &&
                      request.resource.data.presence.lastSeen is timestamp &&
                      // Validate settings object structure
                      request.resource.data.settings is map &&
                      request.resource.data.settings.keys().hasAll(['sendReadReceipts', 'notificationsEnabled']) &&
                      request.resource.data.settings.sendReadReceipts is bool &&
                      request.resource.data.settings.notificationsEnabled is bool &&
                      // Validate timestamps
                      request.resource.data.createdAt is timestamp &&
                      request.resource.data.updatedAt is timestamp &&
                      // Optional fields validation (if present)
                      (!request.resource.data.keys().hasAny(['photoURL']) || request.resource.data.photoURL is string) &&
                      (!request.resource.data.keys().hasAny(['fcmToken']) || request.resource.data.fcmToken is string);

      // Users can update their own profile - allow partial updates
      allow update: if request.auth != null &&
                      request.auth.uid == userId &&
                      // Validate uid cannot be changed
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid']) || request.resource.data.uid == request.auth.uid) &&
                      // If updating username, validate format
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['username']) ||
                       (request.resource.data.username is string &&
                        request.resource.data.username.size() >= 3 &&
                        request.resource.data.username.size() <= 20 &&
                        request.resource.data.username.matches('^[a-z0-9_]+$'))) &&
                      // If updating displayName, validate length
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['displayName']) ||
                       (request.resource.data.displayName is string &&
                        request.resource.data.displayName.size() >= 1 &&
                        request.resource.data.displayName.size() <= 50)) &&
                      // If updating email, validate it's a string
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['email']) ||
                       (request.resource.data.email is string && request.resource.data.email.size() > 0)) &&
                      // If updating presence, validate structure
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['presence']) ||
                       (request.resource.data.presence is map &&
                        (!request.resource.data.presence.keys().hasAny(['status']) || request.resource.data.presence.status in ['online', 'offline']) &&
                        (!request.resource.data.presence.keys().hasAny(['lastSeen']) || request.resource.data.presence.lastSeen is timestamp))) &&
                      // If updating settings, validate structure
                      (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['settings']) ||
                       (request.resource.data.settings is map &&
                        (!request.resource.data.settings.keys().hasAny(['sendReadReceipts']) || request.resource.data.settings.sendReadReceipts is bool) &&
                        (!request.resource.data.settings.keys().hasAny(['notificationsEnabled']) || request.resource.data.settings.notificationsEnabled is bool))) &&
                      // Validate timestamps if present
                      (!request.resource.data.keys().hasAny(['createdAt']) || request.resource.data.createdAt is timestamp) &&
                      (!request.resource.data.keys().hasAny(['updatedAt']) || request.resource.data.updatedAt is timestamp) &&
                      // Validate optional fields if present
                      (!request.resource.data.keys().hasAny(['photoURL']) || request.resource.data.photoURL is string) &&
                      (!request.resource.data.keys().hasAny(['fcmToken']) || request.resource.data.fcmToken is string);
    }

    // Username uniqueness collection
    match /usernames/{username} {
      // Anyone can read usernames to check availability (usernames are public identifiers)
      allow read: if true;

      // Users can only create their own username claim
      // The uid in the document must match the authenticated user
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.uid;

      // Prevent deletion or update of username claims
      // Usernames are permanent once created
      allow update, delete: if false;
    }

    // Conversations - users can access if they're participants
    match /conversations/{conversationId} {
      // Helper function to check if user is a participant
      function isParticipant() {
        return request.auth != null &&
               request.auth.uid in resource.data.participantIds;
      }

      function isParticipantInNewDoc() {
        return request.auth != null &&
               request.auth.uid in request.resource.data.participantIds;
      }

      // Helper function to check if user is the group creator
      function isGroupCreator() {
        return request.auth != null &&
               resource.data.type == 'group' &&
               resource.data.creatorId == request.auth.uid;
      }

      // Helper function to check if only group management fields are being updated
      function isGroupManagementUpdate() {
        let affectedKeys = request.resource.data.diff(resource.data).affectedKeys();
        // These fields can only be updated by the group creator
        let creatorOnlyFields = ['participantIds', 'groupName', 'groupPhotoURL'];
        // Check if any creator-only fields are being modified
        return affectedKeys.hasAny(creatorOnlyFields);
      }

      // Read: Allow authenticated users to read conversations they're participants of
      // This rule works with queries that filter by participantIds array-contains
      allow read: if request.auth != null && (
        // For existing documents, check participantIds
        (resource != null && request.auth.uid in resource.data.participantIds)
      );

      // Get: Allow checking for existence during creation (more permissive for gets only)
      // This is safer than allowing all reads on non-existent docs
      allow get: if request.auth != null;

      // Create: User must include themselves in participantIds and validate conversation type
      // Group size limit: Maximum 50 participants per group
      // Client-side validation in constants/groupLimits.ts (GROUP_SIZE_LIMIT) must match this value
      // Client validation provides UX feedback, server rules provide security enforcement
      allow create: if isParticipantInNewDoc() && (
        // Direct conversation validation
        (request.resource.data.type == 'direct' &&
         request.resource.data.participantIds.size() == 2) ||
        // Group conversation validation
        (request.resource.data.type == 'group' &&
         request.resource.data.creatorId == request.auth.uid &&  // Creator must match auth
         request.resource.data.groupName != null &&              // Group name required
         request.resource.data.groupName.size() > 0 &&
         request.resource.data.groupName.size() <= 50 &&         // Max 50 chars
         request.resource.data.participantIds.size() >= 3 &&     // Min 3 participants
         request.resource.data.participantIds.size() <= 50)      // Max 50 participants
      );

      // Update: Enhanced to check creator permissions for group management fields
      allow update: if isParticipant() && (
        // Regular participants can update per-user fields only
        (!isGroupManagementUpdate() &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['archivedBy', 'deletedBy', 'mutedBy', 'unreadCount', 'lastMessage', 'lastMessageTimestamp', 'updatedAt'])) ||
        // Group creator can update group management fields
        (isGroupCreator() && isGroupManagementUpdate() &&
         // Validate participant array changes if modified
         (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['participantIds']) ||
          (request.resource.data.participantIds.size() >= 3 &&
           request.resource.data.participantIds.size() <= 50 &&
           request.auth.uid in request.resource.data.participantIds)) &&  // Creator cannot remove themselves
         // Validate group name if changed
         (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['groupName']) ||
          (request.resource.data.groupName is string &&
           request.resource.data.groupName.size() > 0 &&
           request.resource.data.groupName.size() <= 50)))
      );

      // Delete: Not allowed (use soft delete via deletedBy field)
      allow delete: if false;

      // Messages within conversations
      match /messages/{messageId} {
        // Helper function to safely check conversation participant without triggering permission errors
        // Uses exists() check to avoid permission denied on get() for non-existent conversations
        function isConversationParticipant() {
          // First check if conversation exists to avoid permission errors on newly created conversations
          return request.auth != null &&
                 exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                 request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
        }

        // Helper function to check if conversation is being created atomically
        // During a transaction, the conversation document hasn't been committed yet,
        // so exists() will return false even though the conversation is being created in the same transaction
        function isAtomicCreation() {
          return request.auth != null &&
                 !exists(/databases/$(database)/documents/conversations/$(conversationId)) &&
                 request.resource.data.conversationId == conversationId;
        }

        // Read: User must be participant in parent conversation
        // OR conversation doesn't exist yet (atomic creation - allow read during transaction)
        allow read: if isConversationParticipant() || !exists(/databases/$(database)/documents/conversations/$(conversationId));

        // Create: User must be participant AND senderId must match auth.uid
        // OR conversation is being created atomically in same transaction
        allow create: if request.auth.uid == request.resource.data.senderId && (
          isConversationParticipant() ||
          isAtomicCreation()
        );

        // Update: User must be participant (for read receipts, status updates)
        allow update: if isConversationParticipant();

        // Delete: Not allowed (messages are immutable)
        allow delete: if false;
      }
    }

    // Default deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
