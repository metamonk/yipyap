# Story 4.2: Group Chat Messaging with Multi-User Support

## Status

Draft

## Story

**As a** user,
**I want** to send and receive messages in group chats with multiple participants,
**so that** I can communicate with several people simultaneously.

## Acceptance Criteria

1. Group chat view displays messages from all participants in chronological order
2. Each message shows sender's name and profile photo (essential in group context for attribution)
3. Sent messages use same real-time Firestore sync as 1:1 chats (Epic 2 infrastructure)
4. All group participants receive real-time updates when any member sends message
5. Message list visually distinguishes sender (e.g., color coding, alignment, or consistent name display)
6. Group chat supports all Epic 2 messaging features: optimistic UI, offline sync, pagination, timestamps
7. Firestore query retrieves messages for group conversation same as 1:1 (subcollection structure)
8. Group chat performance maintains sub-500ms delivery latency even with 50 participants
9. Push notifications sent to all group participants (except sender) when new group message arrives
10. TypeScript types handle group chat messages identically to 1:1 (unified Message interface)

## Tasks / Subtasks

- [ ] **Task 1: Update MessageItem Component for Group Context** (AC: 2, 5)
  - [ ] Open `components/chat/MessageItem.tsx`
  - [ ] Add conditional logic based on `conversation.type === 'group'`
  - [ ] For group messages: **Always** display sender name above message bubble
  - [ ] For group messages: **Always** display sender avatar on left of message
  - [ ] For 1:1 messages: Keep existing behavior (name/avatar only for received messages)
  - [ ] Add visual distinction: Different text color or badge for own messages vs others
  - [ ] Update component props to accept `conversation` object or `isGroupChat` boolean
  - [ ] Test with multiple senders to ensure clear attribution
  - [ ] Source: [architecture/frontend-architecture.md#Component-Template, Story 2.3 Dev Notes]

- [ ] **Task 2: Update Chat Screen for Group Messaging** (AC: 1, 3, 4, 6, 7)
  - [ ] Open `app/(tabs)/conversations/[id].tsx`
  - [ ] Verify existing real-time listener works for group conversations (should already work)
  - [ ] Fetch conversation document to determine if type='group' or 'direct'
  - [ ] Pass conversation type to MessageItem components
  - [ ] Verify message subscription query: `conversations/{id}/messages` (same for 1:1 and group)
  - [ ] Test that all group participants receive real-time updates simultaneously
  - [ ] Ensure optimistic UI updates work for group messages (sender sees message immediately)
  - [ ] Source: [Story 2.3 Dev Notes, architecture/database-schema.md#Firestore-Collections-Structure]

- [ ] **Task 3: Verify Message Service Handles Group Conversations** (AC: 3, 7)
  - [ ] Open `services/messageService.ts`
  - [ ] Confirm `sendMessage()` function is conversation-type agnostic
  - [ ] Verify message subcollection structure identical for 1:1 and group: `conversations/{id}/messages`
  - [ ] No changes needed if service already uses conversationId parameter
  - [ ] Test sending messages in group conversation using existing service
  - [ ] Source: [architecture/frontend-architecture.md#Service-Example, Story 2.1 Dev Notes]

- [ ] **Task 4: Update Conversation Service for Group Last Message** (AC: 3)
  - [ ] Open `services/conversationService.ts`
  - [ ] Verify `updateConversationLastMessage()` works for group conversations
  - [ ] Ensure lastMessage updates correctly when any participant sends message
  - [ ] Update conversation.lastMessageTimestamp for real-time sorting in conversation list
  - [ ] Test that group conversations sort correctly by most recent message
  - [ ] Source: [Story 2.1 Dev Notes, architecture/data-models.md#Conversation]

- [ ] **Task 5: Fetch Sender Info for Group Messages** (AC: 2)
  - [ ] In chat screen component, fetch all participant user profiles when conversation loads
  - [ ] Store participant data in local state: `Map<userId, { displayName, photoURL }>`
  - [ ] Pass sender info to MessageItem component for each message
  - [ ] Handle missing sender info gracefully (e.g., "Unknown User" if profile deleted)
  - [ ] Optimize: Cache participant info to avoid repeated Firestore reads
  - [ ] Source: [architecture/coding-standards.md#Optimistic-Updates, architecture/data-models.md#User]

- [ ] **Task 6: Test Group Chat Performance with 50 Participants** (AC: 8)
  - [ ] Create test conversation with 50 participants using Firebase Emulator
  - [ ] Send test messages and measure delivery latency with console.time()
  - [ ] Verify all 50 participants receive real-time updates within 500ms
  - [ ] Monitor Firestore read operations (should be minimal due to listeners)
  - [ ] Test message rendering performance with FlatList (should handle 50+ concurrent users)
  - [ ] Document performance metrics in test results
  - [ ] Source: [architecture/testing-strategy.md#Integration, Story 2.3 Dev Notes on FlatList optimization]

- [ ] **Task 7: Verify Push Notifications for Group Messages** (AC: 9)
  - [ ] Open `functions/src/notifications.ts`
  - [ ] Verify Cloud Function `sendMessageNotification` handles group conversations
  - [ ] Confirm notification sent to all participantIds except senderId
  - [ ] Test that group message notifications include sender display name
  - [ ] Notification body should show: "{sender} in {groupName}: {messagePreview}"
  - [ ] Verify notification deep link navigates to correct group conversation
  - [ ] Test with 3-10 participants, verify all receive push notifications
  - [ ] Source: [Story 3.5 Dev Notes, functions/src/notifications.ts]

- [ ] **Task 8: Update TypeScript Types for Group Messages (if needed)** (AC: 10)
  - [ ] Open `types/models.ts`
  - [ ] Verify `Message` interface is conversation-type agnostic (should be)
  - [ ] Ensure no type changes needed (Message structure identical for 1:1 and group)
  - [ ] Add JSDoc comments clarifying Message works for both direct and group chats
  - [ ] Update component prop types to accept conversation type information
  - [ ] Source: [architecture/data-models.md#Message, architecture/coding-standards.md#TypeScript-Documentation-Standards]

- [ ] **Task 9: Visual Design for Group Message Attribution** (AC: 2, 5)
  - [ ] Design visual pattern for group messages:
    - [ ] Sender avatar (circular, 32x32px) on left of all messages
    - [ ] Sender display name above message bubble (bold, 12px font)
    - [ ] Message bubble with background color indicating sender (subtle color coding)
    - [ ] Own messages: Right-aligned with blue accent
    - [ ] Others' messages: Left-aligned with gray background
  - [ ] Implement design in MessageItem.tsx using StyleSheet
  - [ ] Add hover/long-press to show full sender details if needed
  - [ ] Ensure accessibility: Color contrast ratios meet WCAG AA standards
  - [ ] Source: [architecture/frontend-architecture.md#Component-Template]

- [ ] **Task 10: Handle Edge Cases for Group Messaging** (AC: 4, 6)
  - [ ] Test: User removed from group → messages no longer visible (handled by Firestore Security Rules)
  - [ ] Test: Offline message sending → queued and synced when back online
  - [ ] Test: Concurrent messages from multiple users → correct chronological order
  - [ ] Test: Very long messages (1000 characters) → proper text wrapping
  - [ ] Test: Rapid message sending (10+ messages/second) → UI remains responsive
  - [ ] Test: Message pagination in group with 500+ messages → efficient loading
  - [ ] Source: [architecture/coding-standards.md#Offline-Handling, Story 2.3 Dev Notes]

- [ ] **Task 11: Write Unit Tests for Group Message Components** (AC: 2, 5)
  - [ ] Create `tests/unit/components/chat/MessageItem.group.test.tsx`
  - [ ] Test: MessageItem displays sender name for group messages
  - [ ] Test: MessageItem displays sender avatar for group messages
  - [ ] Test: MessageItem distinguishes own messages from others in group
  - [ ] Test: MessageItem handles missing sender info gracefully
  - [ ] Use React Native Testing Library
  - [ ] Mock conversation type (direct vs group)
  - [ ] Source: [architecture/testing-strategy.md#Frontend-Component-Test]

- [ ] **Task 12: Write Integration Tests for Group Messaging Flow** (AC: 3, 4, 7, 8)
  - [ ] Create `tests/integration/group-messaging.test.ts`
  - [ ] Test: User sends message in group → all participants receive real-time update
  - [ ] Test: Message appears in correct chronological order with multiple senders
  - [ ] Test: Firestore query retrieves messages from group conversation
  - [ ] Test: Group message delivery latency under 500ms (with 10+ participants)
  - [ ] Test: Push notifications sent to all group members except sender
  - [ ] Use Firebase Emulator Suite for Firestore
  - [ ] Source: [architecture/testing-strategy.md#Test-Organization]

- [ ] **Task 13: Write E2E Tests for Group Chat Experience** (AC: 1, 2, 4, 6)
  - [ ] Create `tests/e2e/group-messaging.e2e.ts`
  - [ ] Test: User opens group chat → sees messages from all participants
  - [ ] Test: User sends message → message appears with sender attribution
  - [ ] Test: Another user sends message → new message appears in real-time
  - [ ] Test: Messages display in chronological order
  - [ ] Test: Group chat supports pagination (scroll up to load older messages)
  - [ ] Test: Offline sync: Send message offline → syncs when online
  - [ ] Use Detox for E2E testing on iOS and Android
  - [ ] Source: [architecture/testing-strategy.md#E2E-Tests]

- [ ] **Task 14: Manual QA Testing with Real Users** (AC: All)
  - [ ] Test group chat with 3, 10, 25, and 50 participants
  - [ ] Verify message attribution is clear and unambiguous
  - [ ] Test real-time message delivery across multiple devices
  - [ ] Verify push notifications arrive on all participant devices
  - [ ] Test offline sync: Send messages offline, verify sync when online
  - [ ] Test performance: Measure latency with 50 participants
  - [ ] Test visual design: Ensure group messages are easy to read and distinguish
  - [ ] Verify conversation list updates correctly with group last message

## Dev Notes

### Previous Story Context

**From Story 4.1: Create Group Chats with Multiple Participants**

Story 4.1 established the group conversation infrastructure:
- Group conversations created with `type='group'`, `participantIds` array (3-50 users), `groupName`, and optional `groupPhotoURL`
- Real-time Firestore listeners use `array-contains` query on `participantIds` (works automatically for groups)
- Group chat view already displays group name and photo in header
- TypeScript `Conversation` interface supports group-specific fields

**Key Insight:** Message subcollections are conversation-scoped, so group messaging uses the **same infrastructure** as 1:1 chats. The primary difference is **UI presentation** (showing sender attribution for all messages).

[Source: Story 4.1 Dev Notes, Epic 4 PRD]

**From Story 2.3: Real-Time 1:1 Chat View with Send/Receive**

Story 2.3 implemented the core messaging infrastructure:
- Chat screen component: `app/(tabs)/conversations/[id].tsx`
- MessageItem component: `components/chat/MessageItem.tsx`
- MessageInput component: `components/chat/MessageInput.tsx`
- useMessages hook: Real-time Firestore listener on messages subcollection
- FlatList with inverted pattern for efficient rendering
- Optimistic UI updates for sent messages
- Auto-scroll to bottom for new messages

**Key Insight:** All messaging components are already built and functional. Story 4.2 primarily involves **updating MessageItem to show sender attribution in group context**.

[Source: Story 2.3 Dev Notes]

**From Story 3.5: Push Notifications for New Messages**

Story 3.5 implemented push notification infrastructure:
- Cloud Function `sendMessageNotification` triggers on new message creation
- Notifications sent to all conversation participants except sender
- Notification payload includes sender display name and message preview
- Deep linking navigates to conversation on notification tap

**Key Insight:** Push notifications **already support group conversations** because the Cloud Function queries `conversation.participantIds` and sends to all recipients. No changes needed for Story 4.2.

[Source: Story 3.5 Dev Notes, functions/src/notifications.ts]

### Architecture Context

#### Tech Stack

**Frontend:**
- React Native 0.81.4 with TypeScript 5.9.2
- State Management: Zustand (latest)
- Navigation: Expo Router (file-based routing)
- Real-time Data: Firestore onSnapshot listeners

**Backend:**
- Firebase JavaScript SDK (latest) - Firestore, Auth, Storage
- Cloud Functions for Firebase (Node.js 18) - Push notifications
- Firestore real-time listeners for message synchronization

**Testing:**
- Jest 29.x + React Native Testing Library
- Firebase Emulator Suite for integration tests
- Detox for E2E testing

[Source: architecture/tech-stack.md]

#### Data Models

**Message Model (Unified for 1:1 and Group):**

```typescript
interface Message {
  id: string;                           // Firestore document ID
  conversationId: string;               // Parent conversation ID
  senderId: string;                     // UID of message sender
  text: string;                         // Message content (1-1000 characters)
  status: 'sending' | 'delivered' | 'read';
  readBy: string[];                     // Array of UIDs who have read the message
  timestamp: firebase.firestore.Timestamp;
  metadata: {
    category?: string;
    sentiment?: string;
    aiProcessed?: boolean;
  };
}
```

**Key Points:**
- Message structure is **identical for 1:1 and group conversations**
- `senderId` identifies who sent the message (critical for group attribution)
- `conversationId` links message to parent conversation (1:1 or group)
- No changes needed to Message interface for Story 4.2

[Source: architecture/data-models.md#Message]

**Conversation Model (Group Fields):**

```typescript
interface Conversation {
  id: string;
  type: 'direct' | 'group';             // Distinguishes 1:1 vs group
  participantIds: string[];             // Array of participant UIDs (2 for direct, 3-50 for group)
  groupName?: string;                   // Required for group chats
  groupPhotoURL?: string;               // Optional group photo
  creatorId?: string;                   // Group creator (for permissions)
  lastMessage: {
    text: string;
    senderId: string;
    timestamp: firebase.firestore.Timestamp;
  };
  lastMessageTimestamp: firebase.firestore.Timestamp;
  unreadCount: Record<string, number>;  // Per-user unread counts
  archivedBy: Record<string, boolean>;
  deletedBy: Record<string, boolean>;
  mutedBy: Record<string, boolean>;
  createdAt: firebase.firestore.Timestamp;
  updatedAt: firebase.firestore.Timestamp;
}
```

**Key Points:**
- `type` field distinguishes group from direct conversations
- `participantIds` array contains 3-50 users for groups (vs 2 for direct)
- Used to determine if sender attribution should be shown in MessageItem component

[Source: architecture/data-models.md#Conversation]

#### Database Schema

**Firestore Messages Subcollection Structure:**

```
conversations/{conversationId}/messages/{messageId}
├── id: string
├── senderId: string                    # Who sent this message (AC: 2)
├── text: string
├── status: 'sending' | 'delivered' | 'read'
├── readBy: string[]
├── timestamp: timestamp                # Chronological ordering (AC: 1)
└── metadata: object
```

**Firestore Query for Messages (Identical for 1:1 and Group):**

```typescript
// Existing query from Story 2.3 - works for groups automatically
const messagesRef = collection(
  firestore,
  'conversations',
  conversationId,
  'messages'
);

const q = query(
  messagesRef,
  orderBy('timestamp', 'desc'),  // Newest first for inverted FlatList
  limit(50)                       // Initial page load
);

const unsubscribe = onSnapshot(q, (snapshot) => {
  // Real-time updates for all conversation participants (AC: 4)
});
```

**Key Points:**
- Message subcollection path is the same for 1:1 and group conversations (AC: 7)
- Real-time listener automatically notifies all participants in `participantIds` array
- No schema changes needed for Story 4.2

[Source: architecture/database-schema.md#Firestore-Collections-Structure]

**Firestore Indexes:**

```json
{
  "collectionGroup": "messages",
  "fields": [
    { "fieldPath": "conversationId", "order": "ASCENDING" },
    { "fieldPath": "timestamp", "order": "DESCENDING" }
  ]
}
```

This composite index already exists (from Story 2.1) and supports efficient message queries for both 1:1 and group conversations.

[Source: architecture/database-schema.md#Firestore-Indexes]

#### File Locations

**Files to Modify:**

```
app/(tabs)/conversations/
└── [id].tsx                            # UPDATE - Pass conversation type to MessageItem

components/chat/
├── MessageItem.tsx                     # UPDATE - Add sender attribution for group messages
└── MessageInput.tsx                    # NO CHANGES - Works for groups as-is

hooks/
└── useMessages.ts                      # NO CHANGES - Works for groups as-is

services/
├── messageService.ts                   # NO CHANGES - Already conversation-type agnostic
└── conversationService.ts              # VERIFY - updateConversationLastMessage works for groups

functions/src/
└── notifications.ts                    # VERIFY - Already handles group notifications (Story 3.5)

types/
└── models.ts                           # UPDATE JSDoc - Clarify Message works for groups
```

**Files to Create:**

```
tests/unit/components/chat/
└── MessageItem.group.test.tsx          # NEW - Unit tests for group message display

tests/integration/
└── group-messaging.test.ts             # NEW - Integration tests for group messaging

tests/e2e/
└── group-messaging.e2e.ts              # NEW - E2E tests for group chat flow
```

[Source: architecture/unified-project-structure.md]

#### Frontend Component Patterns

**MessageItem Component Update for Group Context:**

```typescript
// components/chat/MessageItem.tsx
import React, { FC, memo } from 'react';
import { View, Text, StyleSheet, Image } from 'react-native';

interface MessageItemProps {
  message: Message;
  isOwnMessage: boolean;
  isGroupChat: boolean;                  // NEW - Determines if sender attribution shown
  senderInfo?: {                         // NEW - Sender display info for group messages
    displayName: string;
    photoURL?: string;
  };
}

export const MessageItem: FC<MessageItemProps> = memo(({
  message,
  isOwnMessage,
  isGroupChat,
  senderInfo
}) => {
  // For group chats, ALWAYS show sender attribution (AC: 2)
  const showSenderInfo = isGroupChat;

  return (
    <View style={[
      styles.container,
      isOwnMessage ? styles.ownMessage : styles.otherMessage
    ]}>
      {/* Avatar - shown for all messages in group, only received in 1:1 */}
      {showSenderInfo && senderInfo && (
        <Image
          source={{ uri: senderInfo.photoURL }}
          style={styles.avatar}
        />
      )}

      <View style={styles.messageContent}>
        {/* Sender name - shown for all messages in group (AC: 2) */}
        {showSenderInfo && senderInfo && (
          <Text style={styles.senderName}>{senderInfo.displayName}</Text>
        )}

        {/* Message bubble */}
        <View style={[
          styles.bubble,
          isOwnMessage ? styles.ownBubble : styles.otherBubble
        ]}>
          <Text style={styles.messageText}>{message.text}</Text>
        </View>

        {/* Timestamp */}
        <Text style={styles.timestamp}>
          {formatTimestamp(message.timestamp)}
        </Text>
      </View>
    </View>
  );
});

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    marginVertical: 4,
    paddingHorizontal: 12
  },
  ownMessage: {
    justifyContent: 'flex-end'           // Right-aligned (AC: 5)
  },
  otherMessage: {
    justifyContent: 'flex-start'         // Left-aligned (AC: 5)
  },
  avatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    marginRight: 8
  },
  messageContent: {
    maxWidth: '70%'
  },
  senderName: {
    fontSize: 12,
    fontWeight: 'bold',
    marginBottom: 2,
    color: '#666'
  },
  bubble: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16
  },
  ownBubble: {
    backgroundColor: '#007AFF',          // Blue for own messages
    alignSelf: 'flex-end'
  },
  otherBubble: {
    backgroundColor: '#E5E5EA',          // Gray for others
    alignSelf: 'flex-start'
  },
  messageText: {
    fontSize: 16,
    color: '#000'
  },
  timestamp: {
    fontSize: 11,
    color: '#999',
    marginTop: 2
  }
});
```

[Source: architecture/frontend-architecture.md#Component-Template, Story 2.3 Dev Notes]

**Chat Screen Component Update:**

```typescript
// app/(tabs)/conversations/[id].tsx
import React, { useEffect, useState } from 'react';
import { FlatList, View } from 'react-native';
import { useLocalSearchParams } from 'expo-router';
import { MessageItem } from '@/components/chat/MessageItem';
import { MessageInput } from '@/components/chat/MessageInput';
import { useMessages } from '@/hooks/useMessages';
import { conversationService } from '@/services/conversationService';
import { userService } from '@/services/userService';

export default function ChatScreen() {
  const { id: conversationId } = useLocalSearchParams();
  const { user } = useAuth();
  const { messages, loading, sendMessage } = useMessages(conversationId as string);

  const [conversation, setConversation] = useState<Conversation | null>(null);
  const [participantProfiles, setParticipantProfiles] = useState<Map<string, UserProfile>>(new Map());

  // Fetch conversation to determine type (AC: 2)
  useEffect(() => {
    const fetchConversation = async () => {
      const conv = await conversationService.getConversation(conversationId as string);
      setConversation(conv);

      // If group chat, fetch all participant profiles for sender attribution (AC: 2)
      if (conv.type === 'group') {
        const profiles = await userService.getUserProfiles(conv.participantIds);
        const profileMap = new Map(profiles.map(p => [p.uid, p]));
        setParticipantProfiles(profileMap);
      }
    };

    fetchConversation();
  }, [conversationId]);

  const renderMessage = ({ item: message }: { item: Message }) => {
    const isOwnMessage = message.senderId === user?.uid;
    const isGroupChat = conversation?.type === 'group';
    const senderProfile = participantProfiles.get(message.senderId);

    return (
      <MessageItem
        message={message}
        isOwnMessage={isOwnMessage}
        isGroupChat={isGroupChat}
        senderInfo={senderProfile ? {
          displayName: senderProfile.displayName,
          photoURL: senderProfile.photoURL
        } : undefined}
      />
    );
  };

  return (
    <View style={{ flex: 1 }}>
      {/* Message List (AC: 1, 4) */}
      <FlatList
        data={messages}
        renderItem={renderMessage}
        keyExtractor={(item) => item.id}
        inverted                            // Newest at bottom (AC: 1)
        onEndReached={loadMoreMessages}     // Pagination (AC: 6)
      />

      {/* Message Input */}
      <MessageInput onSend={sendMessage} />
    </View>
  );
}
```

[Source: Story 2.3 Dev Notes, architecture/frontend-architecture.md#Routing-Architecture]

#### Real-Time Messaging Performance

**Group Message Delivery Flow:**

1. User A sends message in group conversation
2. Message written to Firestore: `conversations/{groupId}/messages/{messageId}`
3. Firestore triggers real-time listener for all participants in `participantIds` array
4. All participants (B, C, D, ..., up to 50 users) receive onSnapshot event within 100-500ms
5. UI updates for all participants show new message with sender attribution

**Performance Optimization Strategies:**

- **FlatList Optimization:** Use `inverted`, `removeClippedSubviews`, `maxToRenderPerBatch`, `windowSize` (from Story 2.3)
- **Participant Profile Caching:** Fetch all participant profiles once when conversation loads, store in local state
- **Message Pagination:** Load 50 messages initially, fetch more on scroll (existing from Story 2.3)
- **Firestore Offline Persistence:** Reduces redundant reads for cached messages
- **Optimistic UI Updates:** Sender sees message immediately before Firestore confirms (AC: 6)

**Expected Performance (AC: 8):**
- Message delivery latency: 100-500ms for 50 participants
- UI rendering: 60 FPS even with 50+ messages on screen
- Firestore reads: Minimal due to real-time listeners (only new messages read)

[Source: Story 2.3 Dev Notes, architecture/database-schema.md#Firestore-Indexes]

#### Push Notifications for Group Messages

**Cloud Function Already Handles Groups (from Story 3.5):**

```typescript
// functions/src/notifications.ts - EXISTING CODE
export const sendMessageNotification = functions.firestore
  .document('conversations/{conversationId}/messages/{messageId}')
  .onCreate(async (snapshot, context) => {
    const message = snapshot.data();
    const conversationId = context.params.conversationId;

    // Get conversation to find recipients
    const conversationDoc = await admin
      .firestore()
      .collection('conversations')
      .doc(conversationId)
      .get();

    const conversation = conversationDoc.data();

    // Send to all participants except sender (works for groups!) (AC: 9)
    const recipientIds = conversation.participantIds.filter(
      (id) => id !== message.senderId
    );

    // Fetch sender info for notification
    const senderDoc = await admin.firestore().collection('users').doc(message.senderId).get();
    const senderName = senderDoc.data()?.displayName || 'Someone';

    // Notification payload
    const payload = {
      notification: {
        title: conversation.type === 'group'
          ? `${senderName} in ${conversation.groupName}`   // Group notification title
          : senderName,                                      // 1:1 notification title
        body: message.text.substring(0, 100),               // Message preview
      },
      data: {
        conversationId,
        messageId: context.params.messageId,
        type: conversation.type                             // For deep linking
      }
    };

    // Send to all recipients (AC: 9)
    // ... (FCM token retrieval and sending logic)
  });
```

**Key Points:**
- Cloud Function already supports group conversations (implemented in Story 3.5)
- Notification sent to all `participantIds` except `senderId`
- Notification title distinguishes group messages: "{sender} in {groupName}: {preview}"
- No changes needed for Story 4.2 (AC: 9 already satisfied)

[Source: Story 3.5 Dev Notes, functions/src/notifications.ts]

#### Coding Standards Reminders

**Critical Rules for Story 4.2:**

1. **Component Updates:** Only update MessageItem and Chat Screen components - do not modify service layer
2. **Type Safety:** Ensure `isGroupChat` boolean and `senderInfo` object are properly typed
3. **Performance:** Use `memo()` for MessageItem to prevent unnecessary re-renders with many messages
4. **Error Handling:** Handle missing sender profiles gracefully (show "Unknown User" if profile not found)
5. **JSDoc Documentation:** Update MessageItem component docs to explain group chat behavior

[Source: architecture/coding-standards.md]

### Project Structure Notes

**Alignment:**

All modifications align with existing project structure:
- Chat screen: `app/(tabs)/conversations/[id].tsx`
- MessageItem component: `components/chat/MessageItem.tsx`
- Tests: `tests/unit/components/chat/`, `tests/integration/`, `tests/e2e/`

**No conflicts found** - Story 4.2 extends existing messaging infrastructure without architectural changes.

[Source: architecture/unified-project-structure.md]

### Dependencies on Other Stories

**Depends On (Completed):**

- ✅ **Story 2.1**: Firestore data model with Message subcollections
- ✅ **Story 2.2**: User profile data (displayName, photoURL) for sender attribution
- ✅ **Story 2.3**: Real-time chat infrastructure (MessageItem, useMessages, FlatList)
- ✅ **Story 3.5**: Push notification system (already supports group notifications)
- 🔶 **Story 4.1**: Group conversation creation (Draft status, but infrastructure exists)

**Informs Future Stories:**

- → **Story 4.3**: Group participant management (uses sender attribution from 4.2)
- → **Story 4.4**: Group typing indicators and read receipts (builds on multi-user messaging)

[Source: Epic 4 PRD - Story dependencies]

### Implementation Approach

**Story 4.2 Implementation Strategy:**

Given that the messaging infrastructure (Story 2.3) and notification system (Story 3.5) **already support group conversations**, Story 4.2 focuses on **UI enhancements** to provide clear sender attribution in group chat context.

**Phase 1: Component Updates** (Tasks 1, 2, 8, 9)
1. Update MessageItem component to accept `isGroupChat` and `senderInfo` props
2. Add sender name and avatar display for group messages
3. Update chat screen to fetch conversation type and participant profiles
4. Pass necessary props to MessageItem components

**Phase 2: Service Layer Verification** (Tasks 3, 4, 7)
1. Verify messageService.sendMessage() works for group conversations (should already work)
2. Verify conversationService.updateConversationLastMessage() works for groups
3. Verify Cloud Function sends notifications to all group participants

**Phase 3: Performance Testing** (Task 6)
1. Test group messaging with 10, 25, and 50 participants
2. Measure real-time delivery latency
3. Verify FlatList rendering performance with many messages
4. Monitor Firestore read/write operations

**Phase 4: Testing** (Tasks 11, 12, 13, 14)
1. Unit tests for MessageItem component with group context
2. Integration tests for group message flow
3. E2E tests for full group chat experience
4. Manual QA with real users and devices

**Key Decision Points:**

**Q: Should we cache participant profiles or fetch them per message?**
**A**: Cache participant profiles when conversation loads. Fetch all participant profiles once using `userService.getUserProfiles(participantIds)` and store in Map. This avoids N Firestore reads per message render.

**Q: How to handle participants who leave the group?**
**A**: If a participant's profile is not found (deleted or removed), display "Unknown User" as sender name. This is graceful degradation - message history remains intact.

**Q: Should sender attribution be shown for own messages in group chat?**
**A**: Yes (AC: 2). In group context, showing sender name for ALL messages (including own) reinforces clarity about who said what, especially when scrolling through message history.

**Q: What if real-time listener doesn't fire for some participants?**
**A**: Firestore guarantees eventual consistency. If a participant is offline, they'll receive the message when they reconnect (offline sync from Story 2.3). Real-time delivery should be 95%+ reliable per NFR6.

## Testing

### Testing Standards

**Test File Locations:**

- Component tests: `tests/unit/components/chat/MessageItem.group.test.tsx`
- Service tests: No new service tests needed (verify existing tests cover groups)
- Integration tests: `tests/integration/group-messaging.test.ts`
- E2E tests: `tests/e2e/group-messaging.e2e.ts`

**Testing Frameworks:**

- **Jest** 29.x - Test runner
- **React Native Testing Library** - Component testing
- **Firebase Emulator Suite** - Firestore testing (integration tests)
- **Detox** - End-to-end mobile testing

**Test Coverage Requirements:**

- MessageItem component must have tests for group message display
- Integration tests must verify multi-user real-time message delivery
- E2E tests must validate full group chat user experience
- Performance tests must measure delivery latency with 50 participants

**Mocking Strategy:**

- Mock conversation type (direct vs group) in component tests
- Mock participant profiles in component tests
- Use Firebase Emulator for integration tests (real Firestore behavior)
- No mocks for E2E tests (use real Firebase or emulator)

[Source: architecture/testing-strategy.md]

## Change Log

| Date       | Version | Description                                      | Author             |
|------------|---------|--------------------------------------------------|--------------------|
| 2025-10-22 | 1.0     | Initial story draft for Epic 4.2 Group Messaging | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be populated by the development agent during implementation_

### Debug Log References

_To be populated by the development agent during implementation_

### Completion Notes

_To be populated by the development agent during implementation_

### File List

_To be populated by the development agent during implementation_

## QA Results

_This section will be populated by the QA agent after implementation review._
