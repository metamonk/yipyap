# Story 4.1: Create Group Chats with Multiple Participants

## Status

Draft

## Story

**As a** user,
**I want** to create group chats with multiple participants (3-50 users),
**so that** I can have multi-person conversations.

## Acceptance Criteria

1. Unified conversation creation screen (`/conversations/new`) automatically detects group mode when 2+ recipients selected
2. Group creation flow allows selecting 2+ other users (minimum 3 total including creator)
3. Maximum 50 participants enforced during recipient selection (validation with error message if exceeded)
4. Optional group name field appears automatically when multiple recipients selected
5. Group photo upload available once group is created (in group settings)
6. Firestore conversation document created with type='group', participantIds array, groupName, and groupPhotoURL
7. All participants receive notification/update that they've been added to new group
8. Group chat displays in conversation list for all participants after first message sent
9. Group chat view shows group name and photo in header (instead of 1:1 participant name)
10. TypeScript interfaces updated to support group-specific fields in Conversation type

## Tasks / Subtasks

- [ ] **Task 1: Enhance Unified Conversation Creation for Groups** (AC: 1, 2, 3, 4)
  - [ ] Update `app/(tabs)/conversations/new.tsx` unified creation screen
  - [ ] RecipientTokenField already supports multi-selection; ensure it works for groups
  - [ ] Add automatic group mode detection when 2+ recipients selected
  - [ ] Show optional GroupNameInput component when in group mode
  - [ ] Add validation: Minimum 2 other users (3 total including creator)
  - [ ] Add validation: Maximum 50 total participants with error message
  - [ ] Source: [architecture/frontend-architecture.md#Routing-Architecture]

- [ ] **Task 2: Implement Group-Specific UI Components** (AC: 1, 2, 3, 4)
  - [ ] Enhance existing RecipientTokenField for group participant selection
  - [ ] Implement multi-select user picker (search and select from users collection)
  - [ ] Add validation: Minimum 2 other users (3 total including creator)
  - [ ] Add validation: Maximum 50 total participants with error message
  - [ ] Add required group name text input field (max 50 characters)
  - [ ] Add optional group photo upload button using expo-image-picker
  - [ ] Show selected participants list with ability to remove selections
  - [ ] Add "Create Group" button that triggers group creation
  - [ ] Implement loading state during group creation
  - [ ] Source: [architecture/frontend-architecture.md#Component-Template, architecture/unified-project-structure.md]

- [ ] **Task 3: Implement Group Photo Upload to Firebase Storage** (AC: 5)
  - [ ] In `services/conversationService.ts`, add function `uploadGroupPhoto(imageUri: string, groupId: string): Promise<string>`
  - [ ] Use Firebase Storage SDK to upload photo to `groups/{groupId}/photo.jpg`
  - [ ] Implement image compression using expo-image-manipulator (resize to 512x512, quality 0.7)
  - [ ] Return public download URL from Firebase Storage
  - [ ] Add error handling for upload failures (network, storage quota)
  - [ ] Follow pattern from profile photo upload in `services/userService.ts` if it exists
  - [ ] Source: [architecture/backend-architecture.md#Firebase-Services-Configuration, architecture/tech-stack.md#Storage]

- [ ] **Task 4: Extend Conversation Service for Group Creation** (AC: 6, 7, 8)
  - [ ] Open `services/conversationService.ts`
  - [ ] Add function `createGroupConversation(groupName: string, participantIds: string[], groupPhotoURL?: string): Promise<string>`
  - [ ] Generate new conversation document with:
    - `type: 'group'`
    - `participantIds: [creator, ...selected users]`
    - `groupName: string`
    - `groupPhotoURL: string | null`
    - `creatorId: currentUser.uid`
    - `lastMessage: null`
    - `lastMessageTimestamp: serverTimestamp()`
    - `unreadCount: {}` (empty map, initialized when first message sent)
    - `archivedBy: {}`, `deletedBy: {}`, `mutedBy: {}`
    - `createdAt: serverTimestamp()`
    - `updatedAt: serverTimestamp()`
  - [ ] Add JSDoc documentation for function with @param, @returns, @throws, @example
  - [ ] Return conversation ID after successful creation
  - [ ] Source: [architecture/frontend-architecture.md#Service-Example, architecture/data-models.md#Conversation]

- [ ] **Task 5: Integrate Group Creation Flow in UI** (AC: 2, 3, 4)
  - [ ] In `app/(tabs)/conversations/new.tsx`, wire up group creation when multiple recipients selected
  - [ ] On "Create Group" button press:
    - [ ] Validate group name is not empty
    - [ ] Validate participant count (3-50 total)
    - [ ] If group photo selected, call `uploadGroupPhoto()` first
    - [ ] Call `createGroupConversation()` with name, participants, and photo URL
    - [ ] Show loading spinner during creation
    - [ ] On success, navigate to group chat screen `/conversations/[id]` with new conversation ID
    - [ ] On error, show user-friendly error message (e.g., "Failed to create group. Please try again.")
  - [ ] Add optimistic UI update: Show new group in conversation list immediately
  - [ ] Source: [architecture/coding-standards.md#Optimistic-Updates, architecture/frontend-architecture.md#State-Management-Patterns]

- [ ] **Task 6: Update Conversation List to Display Group Chats** (AC: 8, 9)
  - [ ] Open `components/conversation/ConversationListItem.tsx`
  - [ ] Check conversation.type to differentiate 'direct' vs 'group'
  - [ ] For group chats:
    - [ ] Display `conversation.groupName` instead of participant name
    - [ ] Display `conversation.groupPhotoURL` instead of participant avatar (or default group icon)
    - [ ] Show participant count (e.g., "5 members") as subtitle
  - [ ] For direct chats: Keep existing logic (show other participant name/avatar)
  - [ ] Test real-time updates: New group should appear immediately for all participants
  - [ ] Source: [architecture/frontend-architecture.md#Component-Organization, architecture/data-models.md#Conversation]

- [ ] **Task 7: Update Chat Screen Header for Group Chats** (AC: 9)
  - [ ] Open `app/(tabs)/conversations/[id].tsx`
  - [ ] Update header to check conversation.type
  - [ ] For group chats:
    - [ ] Display group name in header title
    - [ ] Display group photo in header (or default group icon)
    - [ ] Add "Group Info" button in header (navigate to future group settings screen)
  - [ ] For direct chats: Keep existing logic (show participant name/avatar)
  - [ ] Source: [architecture/frontend-architecture.md#Routing-Architecture]

- [ ] **Task 8: Update TypeScript Interfaces for Group Support** (AC: 10)
  - [ ] Open `types/models.ts`
  - [ ] Update `Conversation` interface to include:
    - [ ] `groupName?: string` - Optional group name
    - [ ] `groupPhotoURL?: string` - Optional group photo URL
    - [ ] `creatorId?: string` - UID of group creator
  - [ ] Verify `type` field is typed as `'direct' | 'group'`
  - [ ] Ensure `participantIds` is `string[]` (array, not limited to 2)
  - [ ] Add JSDoc comments for new fields
  - [ ] Source: [architecture/data-models.md#Conversation, architecture/coding-standards.md#TypeScript-Documentation-Standards]

- [ ] **Task 9: Update Firestore Security Rules for Group Creation** (AC: 6)
  - [ ] Open `firebase/firestore.rules`
  - [ ] Update `conversations` collection rules to allow group creation:
    - [ ] User can create conversation if they're in participantIds
    - [ ] For group conversations: Require groupName field
    - [ ] For group conversations: Require creatorId matches auth.uid
    - [ ] Validate participantIds array length >= 3 for type='group'
    - [ ] Validate participantIds array length <= 50
  - [ ] Example rule:
    ```
    allow create: if request.auth != null &&
      request.auth.uid in request.resource.data.participantIds &&
      (request.resource.data.type == 'direct' ||
       (request.resource.data.type == 'group' &&
        request.resource.data.creatorId == request.auth.uid &&
        request.resource.data.groupName != null &&
        request.resource.data.participantIds.size() >= 3 &&
        request.resource.data.participantIds.size() <= 50));
    ```
  - [ ] Test rules using Firebase Emulator with valid/invalid group creation attempts
  - [ ] Source: [architecture/database-schema.md#Firestore-Security-Rules]

- [ ] **Task 10: Add Real-Time Group Subscription for All Participants** (AC: 7, 8)
  - [ ] Verify existing `conversationService.subscribeToConversations()` uses `array-contains` query
  - [ ] This automatically subscribes all participants to group conversations in real-time
  - [ ] When group is created, all participants in `participantIds` will receive real-time update
  - [ ] Test: Create group with multiple users, verify group appears in all participants' conversation lists
  - [ ] Add integration test for real-time group subscription
  - [ ] Source: [architecture/frontend-architecture.md#Service-Example, architecture/database-schema.md#Firestore-Collections-Structure]

- [ ] **Task 11: Implement Group Creation Notification** (AC: 7)
  - [ ] Option A: Push notification via Cloud Function trigger (if Epic 3 Story 3.5 implemented)
    - [ ] Cloud Function on conversation create triggers notification to all participants
    - [ ] Notification body: "{creator} added you to group '{groupName}'"
  - [ ] Option B: In-app notification via real-time listener (simpler for MVP)
    - [ ] When new group appears in conversation list, show banner notification
    - [ ] Banner: "You've been added to '{groupName}' by {creator}"
  - [ ] Recommend Option B for MVP (Option A for future enhancement)
  - [ ] Implement banner notification component in conversation list screen
  - [ ] Source: [architecture/backend-architecture.md#Cloud-Function-Template]

- [ ] **Task 12: Write Unit Tests for Group Creation Service** (AC: 6)
  - [ ] Create `tests/unit/services/conversationService.groupCreation.test.ts`
  - [ ] Test: createGroupConversation creates document with correct fields
  - [ ] Test: createGroupConversation validates participant count (min 3, max 50)
  - [ ] Test: createGroupConversation requires groupName
  - [ ] Test: createGroupConversation sets creatorId to current user
  - [ ] Test: createGroupConversation handles upload failure gracefully
  - [ ] Test: createGroupConversation returns conversation ID
  - [ ] Mock Firestore SDK using Jest mocks
  - [ ] Source: [architecture/testing-strategy.md#Frontend-Tests]

- [ ] **Task 13: Write Component Tests for Group Creation Screen** (AC: 2, 3, 4)
  - [ ] Create `tests/unit/components/UnifiedConversationCreation.test.tsx`
  - [ ] Test: User picker allows selecting multiple users
  - [ ] Test: Validation error shown when less than 2 other users selected
  - [ ] Test: Validation error shown when more than 50 participants selected
  - [ ] Test: Group name field is required
  - [ ] Test: Group photo upload button opens image picker
  - [ ] Test: Create button triggers group creation with correct data
  - [ ] Test: Loading state displayed during group creation
  - [ ] Test: Navigation to group chat on successful creation
  - [ ] Use React Native Testing Library
  - [ ] Source: [architecture/testing-strategy.md#Frontend-Component-Test]

- [ ] **Task 14: Write Integration Tests for Group Creation Flow** (AC: 6, 7, 8)
  - [ ] Create `tests/integration/group-creation.test.ts`
  - [ ] Test: User creates group → Firestore document created with correct structure
  - [ ] Test: Group appears in creator's conversation list immediately
  - [ ] Test: Group appears in all participants' conversation lists (real-time sync)
  - [ ] Test: Group photo uploads to Firebase Storage and URL saved in Firestore
  - [ ] Test: Group creation fails if participant count exceeds 50
  - [ ] Test: Firestore Security Rules enforce group creator permissions
  - [ ] Use Firebase Emulator Suite for Firestore and Storage
  - [ ] Source: [architecture/testing-strategy.md#Test-Organization]

- [ ] **Task 15: Write E2E Tests for Group Creation** (AC: 1, 2, 4, 8)
  - [ ] Create `tests/e2e/group-creation.e2e.ts`
  - [ ] Test: User taps "New Group" → navigates to group creation screen
  - [ ] Test: User selects participants → selected users appear in list
  - [ ] Test: User enters group name and uploads photo → group created successfully
  - [ ] Test: New group appears in conversation list with group name and photo
  - [ ] Test: User taps group → navigates to group chat screen with group name in header
  - [ ] Test: Other participants see new group in their conversation lists
  - [ ] Use Detox for E2E testing on iOS and Android
  - [ ] Source: [architecture/testing-strategy.md#E2E-Tests]

- [ ] **Task 16: Manual QA Testing on Physical Devices** (AC: All)
  - [ ] Test "New Group" button appears in conversation list (iOS & Android)
  - [ ] Test group creation flow with 3, 10, 50 participants
  - [ ] Test validation: Minimum 3 participants error message
  - [ ] Test validation: Maximum 50 participants error message
  - [ ] Test group name input (empty, valid, max length)
  - [ ] Test group photo upload (select, compress, upload success/failure)
  - [ ] Test group appears in all participants' conversation lists in real-time
  - [ ] Test group chat header displays group name and photo correctly
  - [ ] Test offline: group creation queues and syncs when online
  - [ ] Verify Firestore Security Rules prevent unauthorized group creation

## Dev Notes

### Previous Story Context

**From Story 3.7: Unread Message Badge Counts**

Story 3.7 completed the notification infrastructure including badge count management. This infrastructure will be leveraged for group chat notifications when messages are sent.

Key insights:
- `unreadCount` map structure already supports multiple participants (perfect for groups)
- Real-time Firestore listeners use `array-contains` for participantIds (already group-compatible)
- Notification service handles push notifications to multiple recipients

**From Story 2.1-2.6: Core Messaging Infrastructure**

The existing conversation and message infrastructure is built to support both 1:1 and group conversations:
- `Conversation.type` field distinguishes 'direct' vs 'group'
- `participantIds` is an array (not limited to 2 users)
- Message subcollections are conversation-scoped (works for any participant count)

[Source: Story 3.7 Dev Notes, Story 2.3 Dev Notes]

### Architecture Context

#### Tech Stack

**Frontend:**
- React Native 0.81.4 with TypeScript 5.9.2
- State Management: Zustand (latest)
- Image Upload: expo-image-picker + expo-image-manipulator
- Navigation: Expo Router (file-based routing)

**Backend:**
- Firebase JavaScript SDK (latest) - Firestore, Storage, Auth
- Firebase Storage for group photos
- Firestore real-time listeners for group synchronization

**Testing:**
- Jest 29.x + React Native Testing Library
- Firebase Emulator Suite
- Detox for E2E testing

[Source: architecture/tech-stack.md]

#### Data Models

**Conversation Model (Group Fields):**

```typescript
interface Conversation {
  id: string;
  type: 'direct' | 'group';           // AC: 6 - Distinguish conversation type
  participantIds: string[];           // AC: 6 - Array of participant UIDs (3-50 for groups)
  groupName?: string;                 // AC: 4, 6 - Required for group chats
  groupPhotoURL?: string;             // AC: 5, 6 - Optional group photo URL
  creatorId?: string;                 // AC: 6 - UID of group creator (for permissions)
  lastMessage: {
    text: string;
    senderId: string;
    timestamp: firebase.firestore.Timestamp;
  };
  lastMessageTimestamp: firebase.firestore.Timestamp;
  unreadCount: Record<string, number>;  // Per-user unread counts (works for groups)
  archivedBy: Record<string, boolean>;
  deletedBy: Record<string, boolean>;
  mutedBy: Record<string, boolean>;
  createdAt: firebase.firestore.Timestamp;
  updatedAt: firebase.firestore.Timestamp;
}
```

**Key Points:**
- `type: 'group'` identifies group conversations (AC: 6)
- `participantIds` array supports 3-50 users for groups (AC: 2, 3)
- `groupName` is required for group chats (AC: 4, 6)
- `creatorId` tracks group creator for future permission checks (Story 4.3)
- Existing maps (`unreadCount`, `archivedBy`, etc.) are per-user and scale to groups

[Source: architecture/data-models.md#Conversation]

#### Database Schema

**Firestore Collections Structure:**

```
conversations/{conversationId}
  ├── type: 'direct' | 'group'
  ├── participantIds: string[]        // array-contains query for all participants
  ├── groupName?: string
  ├── groupPhotoURL?: string
  ├── creatorId?: string
  ├── lastMessage: object
  ├── lastMessageTimestamp: timestamp
  ├── unreadCount: { [userId]: number }
  ├── archivedBy: { [userId]: boolean }
  ├── deletedBy: { [userId]: boolean }
  ├── mutedBy: { [userId]: boolean }
  ├── createdAt: timestamp
  ├── updatedAt: timestamp
  └── messages/ (subcollection)       // Same structure for groups and direct chats
```

**Firestore Indexes:**

Existing composite index already supports group conversations:
```json
{
  "collectionGroup": "conversations",
  "fields": [
    { "fieldPath": "participantIds", "arrayConfig": "CONTAINS" },
    { "fieldPath": "lastMessageTimestamp", "order": "DESCENDING" }
  ]
}
```

This index enables efficient queries like:
```typescript
where('participantIds', 'array-contains', userId)
  .orderBy('lastMessageTimestamp', 'desc')
```

The `array-contains` query returns ALL conversations where the user is a participant, including groups with 50 members.

[Source: architecture/database-schema.md]

#### Firebase Storage Structure

**Group Photo Storage Path:**

```
gs://{bucket}/groups/{groupId}/photo.jpg
```

**Upload Process:**
1. Compress image to 512x512 using expo-image-manipulator (quality 0.7)
2. Upload compressed image to Firebase Storage
3. Generate public download URL
4. Store URL in conversation document as `groupPhotoURL`

**Security Rules:**

```javascript
service firebase.storage {
  match /b/{bucket}/o {
    match /groups/{groupId}/photo.jpg {
      allow write: if request.auth != null &&
        request.auth.uid == firestore.get(/databases/(default)/documents/conversations/$(groupId)).data.creatorId;
      allow read: if request.auth != null;
    }
  }
}
```

Only group creator can upload/update group photo. All authenticated users can read group photos.

[Source: architecture/backend-architecture.md#Firebase-Services-Configuration]

#### Firestore Security Rules (Group Creation)

**Conversation Creation Rules:**

```javascript
match /conversations/{conversationId} {
  allow create: if request.auth != null &&
    request.auth.uid in request.resource.data.participantIds &&
    (
      // Direct conversation validation
      (request.resource.data.type == 'direct' &&
       request.resource.data.participantIds.size() == 2) ||

      // Group conversation validation (AC: 2, 3, 6)
      (request.resource.data.type == 'group' &&
       request.resource.data.creatorId == request.auth.uid &&  // Creator must match auth
       request.resource.data.groupName != null &&              // Group name required
       request.resource.data.groupName.size() > 0 &&
       request.resource.data.participantIds.size() >= 3 &&     // Min 3 participants
       request.resource.data.participantIds.size() <= 50)      // Max 50 participants
    );
}
```

**Key Validations:**
- User must be in `participantIds` to create conversation
- For groups: `type='group'`, `creatorId` matches auth.uid, `groupName` exists
- Participant count: 3-50 for groups (AC: 2, 3)
- Group name must not be empty (AC: 4)

[Source: architecture/database-schema.md#Firestore-Security-Rules]

#### File Locations

**Files to Create:**
```
app/(tabs)/conversations/
└── new.tsx                         # UPDATED - Unified conversation creation with group support

tests/unit/services/
└── conversationService.groupCreation.test.ts  # NEW - Service tests

tests/unit/components/
└── UnifiedConversationCreation.test.tsx  # NEW - Component tests for group mode

tests/integration/
└── group-creation.test.ts           # NEW - Integration tests

tests/e2e/
└── group-creation.e2e.ts            # NEW - E2E tests
```

**Files to Modify:**
```
app/(tabs)/conversations/
├── index.tsx                        # UPDATE - Add "New Group" button
└── [id].tsx                         # UPDATE - Group chat header display

components/conversation/
└── ConversationListItem.tsx         # UPDATE - Display group name/photo

services/
└── conversationService.ts           # UPDATE - Add createGroupConversation()

types/
└── models.ts                        # UPDATE - Add group fields to Conversation interface

firebase/
├── firestore.rules                  # UPDATE - Add group creation rules
└── storage.rules                    # UPDATE - Add group photo rules
```

[Source: architecture/unified-project-structure.md]

#### Frontend Component Patterns

**Group Creation Screen Component Structure:**

```typescript
// app/(tabs)/conversations/new.tsx (enhanced for group support)
import React, { useState, useEffect } from 'react';
import { View, TextInput, Button } from 'react-native';
import { useRouter } from 'expo-router';
import { RecipientTokenField } from '@/components/conversation/RecipientTokenField';
import { GroupNameInput } from '@/components/conversation/GroupNameInput';
import { conversationService } from '@/services/conversationService';
import { useAuth } from '@/hooks/useAuth';

export default function UnifiedConversationCreationScreen() {
  const router = useRouter();
  const { user } = useAuth();
  const [recipients, setRecipients] = useState<User[]>([]);
  const [groupName, setGroupName] = useState('');
  const [isGroupMode, setIsGroupMode] = useState(false);
  const [isCreating, setIsCreating] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleCreateGroup = async () => {
    // Validation: AC 2, 3, 4
    if (!groupName.trim()) {
      setError('Group name is required');
      return;
    }

    const totalParticipants = selectedUsers.length + 1; // +1 for creator
    if (totalParticipants < 3) {
      setError('Select at least 2 other users (minimum 3 total)');
      return;
    }

    if (totalParticipants > 50) {
      setError('Maximum 50 participants allowed');
      return;
    }

    setIsCreating(true);
    setError(null);

    try {
      // Upload photo if selected (AC: 5)
      let photoURL: string | undefined;
      if (groupPhotoUri) {
        photoURL = await conversationService.uploadGroupPhoto(groupPhotoUri, 'temp-id');
      }

      // Create group conversation (AC: 6)
      const participantIds = [user!.uid, ...selectedUsers];
      const conversationId = await conversationService.createGroupConversation(
        groupName,
        participantIds,
        photoURL
      );

      // Navigate to new group chat
      router.push(`/conversations/${conversationId}`);
    } catch (err) {
      setError('Failed to create group. Please try again.');
      console.error('Group creation error:', err);
    } finally {
      setIsCreating(false);
    }
  };

  return (
    <View>
      {/* Group name input */}
      {/* User picker with search */}
      {/* Selected users list */}
      {/* Group photo upload button */}
      {/* Create button with loading state */}
      {/* Error message display */}
    </View>
  );
}
```

[Source: architecture/frontend-architecture.md#Component-Template]

#### Service Layer Implementation

**Group Conversation Creation Service:**

```typescript
// services/conversationService.ts

/**
 * Creates a new group conversation with multiple participants
 * @param groupName - The name of the group (required, max 50 characters)
 * @param participantIds - Array of user UIDs including creator (3-50 total)
 * @param groupPhotoURL - Optional group photo URL from Firebase Storage
 * @returns Promise resolving to the created conversation ID
 * @throws {FirebaseError} When Firestore write fails or validation fails
 * @example
 * ```typescript
 * const conversationId = await createGroupConversation(
 *   'Team Chat',
 *   ['creatorUid', 'user2Uid', 'user3Uid'],
 *   'https://storage.googleapis.com/...'
 * );
 * ```
 */
export async function createGroupConversation(
  groupName: string,
  participantIds: string[],
  groupPhotoURL?: string
): Promise<string> {
  const db = getFirebaseDb();
  const currentUser = getCurrentUser();

  // Validation
  if (!groupName || groupName.trim().length === 0) {
    throw new Error('Group name is required');
  }

  if (participantIds.length < 3 || participantIds.length > 50) {
    throw new Error('Group must have 3-50 participants');
  }

  const conversationData: Partial<Conversation> = {
    type: 'group',
    participantIds,
    groupName: groupName.trim(),
    groupPhotoURL: groupPhotoURL || null,
    creatorId: currentUser.uid,
    lastMessage: null,
    lastMessageTimestamp: serverTimestamp(),
    unreadCount: {},
    archivedBy: {},
    deletedBy: {},
    mutedBy: {},
    createdAt: serverTimestamp(),
    updatedAt: serverTimestamp(),
  };

  try {
    const docRef = await addDoc(
      collection(db, 'conversations'),
      conversationData
    );

    return docRef.id;
  } catch (error) {
    console.error('[ConversationService] Error creating group conversation:', error);
    throw error;
  }
}

/**
 * Uploads a group photo to Firebase Storage with compression
 * @param imageUri - Local URI of the image to upload
 * @param groupId - The group conversation ID (or temp ID during creation)
 * @returns Promise resolving to the public download URL
 * @throws {Error} When upload fails or image processing fails
 */
export async function uploadGroupPhoto(
  imageUri: string,
  groupId: string
): Promise<string> {
  try {
    // Compress image using expo-image-manipulator
    const compressedImage = await ImageManipulator.manipulateAsync(
      imageUri,
      [{ resize: { width: 512, height: 512 } }],
      { compress: 0.7, format: ImageManipulator.SaveFormat.JPEG }
    );

    // Upload to Firebase Storage
    const storage = getStorage();
    const storageRef = ref(storage, `groups/${groupId}/photo.jpg`);

    const response = await fetch(compressedImage.uri);
    const blob = await response.blob();

    await uploadBytes(storageRef, blob);

    // Get public download URL
    const downloadURL = await getDownloadURL(storageRef);

    return downloadURL;
  } catch (error) {
    console.error('[ConversationService] Error uploading group photo:', error);
    throw new Error('Failed to upload group photo');
  }
}
```

[Source: architecture/frontend-architecture.md#Service-Example, architecture/coding-standards.md#TypeScript-Documentation-Standards]

#### Real-Time Synchronization for Groups

**Existing Query Already Supports Groups:**

The current conversation subscription uses `array-contains` which automatically works for group conversations:

```typescript
// services/conversationService.ts - EXISTING (no changes needed)
subscribeToConversations(userId: string, callback: (conversations: Conversation[]) => void) {
  const q = query(
    collection(firestore, 'conversations'),
    where('participantIds', 'array-contains', userId),  // Works for groups!
    where(`deletedBy.${userId}`, '!=', true),
    orderBy('lastMessageTimestamp', 'desc'),
    limit(30)
  );

  return onSnapshot(q, (snapshot) => {
    const conversations = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
    }) as Conversation);
    callback(conversations);
  });
}
```

**How it works for groups:**
- When group is created with `participantIds: ['user1', 'user2', 'user3']`
- Each user has an active listener with `where('participantIds', 'array-contains', userId)`
- Firestore automatically returns the new group conversation to ALL participants
- Group appears in each participant's conversation list in real-time (AC: 7, 8)

**No code changes needed** - existing infrastructure supports groups automatically.

[Source: architecture/frontend-architecture.md#Service-Example, architecture/database-schema.md#Firestore-Indexes]

#### Coding Standards Reminders

**Critical Rules for Story 4.1:**

1. **Firebase Access**: Never access Firebase directly from components - use service layer
   - Components call `conversationService.createGroupConversation()`
   - Services handle Firestore and Storage operations

2. **Optimistic Updates**: Show immediate UI feedback before server confirmation
   - Add group to local conversation list immediately
   - Update after server confirms creation

3. **Error Handling**: All async operations must have try-catch with user-friendly errors
   - "Failed to create group. Please try again." (not Firebase error codes)
   - Log full error to console for debugging

4. **Type Safety**: All functions must have proper TypeScript types
   - No `any` types without explanation
   - Use `Conversation` interface from `types/models.ts`

5. **JSDoc Documentation**: All public functions must have @param, @returns, @throws, @example
   - See service layer examples above

6. **Validation**: Validate all user input before calling services
   - Group name not empty (AC: 4)
   - Participant count 3-50 (AC: 2, 3)
   - Show validation errors to user immediately

[Source: architecture/coding-standards.md]

### Project Structure Notes

**Alignment:**

All file paths follow existing project structure:
- Enhanced unified conversation creation screen in `app/(tabs)/conversations/new.tsx`
- Service functions in `services/conversationService.ts`
- TypeScript types in `types/models.ts`
- Tests in `tests/unit/`, `tests/integration/`, `tests/e2e/`

**No conflicts found** - group chat is a natural extension of existing conversation infrastructure.

[Source: architecture/unified-project-structure.md]

### Dependencies on Other Stories

**Depends On (Completed):**

- ✅ **Story 1.1-1.4**: User authentication and profile management (Firebase Auth)
- ✅ **Story 2.1**: Firestore data model with Conversation type field
- ✅ **Story 2.2**: User search functionality (needed for participant selection)
- ✅ **Story 2.3**: Real-time chat infrastructure (works for groups automatically)
- ✅ **Story 3.5**: Push notifications (optional for group creation notifications)
- ✅ **Story 3.7**: Unread count infrastructure (already supports group participants)

**Informs Future Stories:**

- → **Story 4.2**: Group chat messaging (uses group conversations created here)
- → **Story 4.3**: Group participant management (uses creatorId for permissions)
- → **Story 4.4**: Group typing indicators and read receipts

[Source: Epic 4 PRD - Story dependencies]

### Implementation Approach

**Story 4.1 Implementation Strategy:**

Given that existing infrastructure (data model, real-time listeners, security rules) already supports the concept of multiple participants, Story 4.1 focuses on **building the UI and service layer** for group creation.

**Phase 1: Backend Service Layer** (Tasks 3, 4, 8, 9)
1. Implement group photo upload to Firebase Storage
2. Add `createGroupConversation()` to conversation service
3. Update TypeScript interfaces for group fields
4. Update Firestore Security Rules for group creation validation

**Phase 2: Frontend UI** (Tasks 1, 2, 5, 6, 7)
1. Add "New Group" button to conversation list
2. Create group creation screen with user picker
3. Integrate group creation flow with service layer
4. Update conversation list to display group chats
5. Update chat screen header for group display

**Phase 3: Real-Time Sync & Notifications** (Tasks 10, 11)
1. Verify real-time group subscription works for all participants
2. Implement in-app notification for group creation (optional push notification)

**Phase 4: Testing** (Tasks 12, 13, 14, 15, 16)
1. Unit tests for service layer
2. Component tests for group creation screen
3. Integration tests for full group creation flow
4. E2E tests for user journey
5. Manual QA on physical devices

**Key Decision Points:**

**Q: Should we allow group creation with only 2 participants?**
**A**: No. Per AC: 2, minimum is 3 total participants (creator + 2 others). This differentiates groups from direct chats and justifies the group creation flow.

**Q: How to handle group photo upload failure?**
**A**: Group creation should still succeed without photo. Show error message about photo upload failure, but create group with default group icon. User can update photo later (Story 4.3).

**Q: Should we send push notifications when users are added to groups?**
**A**: For MVP, in-app notification is sufficient (real-time listener shows new group). Push notification can be added via Cloud Function in future enhancement.

**Q: What happens if Firestore Security Rules reject group creation?**
**A**: Frontend validation should prevent this (participant count check). If rules reject anyway, show generic error to user and log specific error for debugging.

## Testing

### Testing Standards

**Test File Locations:**

- Service tests: `tests/unit/services/conversationService.groupCreation.test.ts`
- Component tests: `tests/unit/components/UnifiedConversationCreation.test.tsx`
- Integration tests: `tests/integration/group-creation.test.ts`
- E2E tests: `tests/e2e/group-creation.e2e.ts`

**Testing Frameworks:**

- **Jest** 29.x - Test runner
- **React Native Testing Library** - Component testing
- **Firebase Emulator Suite** - Firestore and Storage testing (integration tests)
- **Detox** - End-to-end mobile testing

**Test Coverage Requirements:**

- All group creation service functions must have unit tests
- Group creation screen must have component tests
- Integration tests must verify E2E group creation flow (UI → Service → Firestore)
- E2E tests must validate group creation on both iOS and Android devices

**Mocking Strategy:**

- Mock Firestore SDK using Jest mocks for unit tests
- Mock Firebase Storage for unit tests
- Use Firebase Emulator for integration tests (real Firestore and Storage)
- Mock useAuth hook in component tests
- No mocks for E2E tests (use real Firebase or emulator)

[Source: architecture/testing-strategy.md]

## Change Log

| Date       | Version | Description                                  | Author             |
|------------|---------|----------------------------------------------|--------------------|
| 2025-10-22 | 1.0     | Initial story draft for Epic 4.1 Group Chats | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used

_To be populated by the development agent during implementation_

### Debug Log References

_To be populated by the development agent during implementation_

### Completion Notes

_To be populated by the development agent during implementation_

### File List

_To be populated by the development agent during implementation_

## QA Results

_This section will be populated by the QA agent after implementation review._
