# Story 6.4: Auto-Archive Manual Testing Guide

## Prerequisites

1. **Firebase Emulator Running** (for safe testing without affecting production)
   ```bash
   npm run test:integration:with-emulator
   ```
   OR start emulators manually:
   ```bash
   firebase emulators:start
   ```

2. **Test User Account** with capacity settings configured
3. **Service Account Key** (for running scripts): `serviceAccountKey.json`

---

## Test Flow Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                    Auto-Archive Test Flow                        │
└─────────────────────────────────────────────────────────────────┘

1. Setup: Create test user with capacity limit (e.g., 3 messages/day)
2. Seed: Create 10+ low-priority messages (exceed capacity)
3. Trigger: Run daily workflow manually
4. Verify: Check auto-archive results
   ├─ 3 messages kept in "Meaningful 10"
   ├─ 7+ messages auto-archived
   ├─ Boundary messages sent (max 1/fan/week)
   └─ Safety checks respected (no business/urgent/VIP archived)
5. Test Undo: Restore archived conversation within 24 hours
6. Verify Expiry: Confirm undo expires after 24 hours
```

---

## Step 1: Setup Test User

### Option A: Using Firebase Console

1. Open Firebase Console → Firestore Database
2. Navigate to `users` collection
3. Create/update a test user document:

```json
{
  "uid": "test-creator-123",
  "username": "testcreator",
  "displayName": "Test Creator",
  "email": "test@example.com",
  "settings": {
    "capacity": {
      "dailyLimit": 3,
      "autoArchiveEnabled": true,
      "boundaryMessage": "Hi! 👋\n\nI get hundreds of messages daily and can only respond to a few each day.\n\nFor quick answers, check out my FAQ: {{faqUrl}}\nOr join our community: {{communityUrl}}\n\n[This message was sent automatically]",
      "requireEditingForBusiness": true
    },
    "notifications": {
      "quietHoursStart": "22:00",
      "quietHoursEnd": "08:00"
    },
    "links": {
      "faqUrl": "https://example.com/faq",
      "communityUrl": "https://discord.gg/example"
    }
  },
  "createdAt": "FIRESTORE_TIMESTAMP",
  "updatedAt": "FIRESTORE_TIMESTAMP"
}
```

### Option B: Using Script

Create `functions/scripts/setupTestUser.ts`:

```typescript
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function setupTestUser() {
  const userId = 'test-creator-123';

  await db.collection('users').doc(userId).set({
    uid: userId,
    username: 'testcreator',
    displayName: 'Test Creator',
    email: 'test@example.com',
    settings: {
      capacity: {
        dailyLimit: 3,
        autoArchiveEnabled: true,
        boundaryMessage: "Hi! 👋\n\nI get hundreds of messages daily and can only respond to a few each day.\n\nFor quick answers, check out my FAQ: {{faqUrl}}\nOr join our community: {{communityUrl}}\n\n[This message was sent automatically]",
        requireEditingForBusiness: true
      },
      notifications: {
        quietHoursStart: '22:00',
        quietHoursEnd: '08:00'
      },
      links: {
        faqUrl: 'https://example.com/faq',
        communityUrl: 'https://discord.gg/example'
      }
    },
    presence: { status: 'online', lastSeen: admin.firestore.Timestamp.now() },
    createdAt: admin.firestore.Timestamp.now(),
    updatedAt: admin.firestore.Timestamp.now()
  });

  console.log('✅ Test user created:', userId);
}

setupTestUser().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/setupTestUser.ts
```

---

## Step 2: Seed Test Messages

Create `functions/scripts/seedAutoArchiveMessages.ts`:

```typescript
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function seedMessages() {
  const userId = 'test-creator-123';

  const testMessages = [
    // High priority (should NOT be archived)
    { senderId: 'fan-vip-1', text: 'Important business opportunity!', category: 'business_opportunity', isVIP: true },
    { senderId: 'fan-urgent-1', text: 'Urgent request!', category: 'urgent' },
    { senderId: 'fan-crisis-1', text: 'I really need help', sentiment: 'negative', sentimentScore: -0.8 },

    // Low priority (SHOULD be archived - beyond capacity of 3)
    { senderId: 'fan-1', text: 'Love your content!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-2', text: 'Just wanted to say hi!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-3', text: 'You inspire me!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-4', text: 'Keep up the great work!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-5', text: 'Thanks for everything!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-6', text: 'Big fan here!', category: 'fan_engagement', sentiment: 'positive' },
    { senderId: 'fan-7', text: 'Your videos are amazing!', category: 'fan_engagement', sentiment: 'positive' },
  ];

  console.log('Creating conversations and messages...\n');

  for (let i = 0; i < testMessages.length; i++) {
    const msg = testMessages[i];
    const convId = `test-conv-${i + 1}`;
    const msgId = `test-msg-${i + 1}`;

    // Create conversation
    await db.collection('conversations').doc(convId).set({
      id: convId,
      participantIds: [userId, msg.senderId],
      lastMessage: msg.text,
      lastMessageTimestamp: admin.firestore.Timestamp.now(),
      isArchived: false,
      createdAt: admin.firestore.Timestamp.now(),
      updatedAt: admin.firestore.Timestamp.now()
    });

    // Create message
    const metadata: any = {
      category: msg.category || 'fan_engagement',
      sentiment: msg.sentiment || 'positive',
      sentimentScore: msg.sentimentScore || 0.7,
      aiProcessed: true
    };

    if (msg.isVIP) {
      metadata.relationshipContext = { isVIP: true, conversationAge: 45, lastInteraction: admin.firestore.Timestamp.now(), messageCount: 20 };
    }

    await db.collection('conversations').doc(convId).collection('messages').doc(msgId).set({
      id: msgId,
      conversationId: convId,
      senderId: msg.senderId,
      text: msg.text,
      status: 'delivered',
      readBy: [],
      timestamp: admin.firestore.Timestamp.now(),
      metadata
    });

    console.log(`✅ Created: ${convId} - "${msg.text}" (${msg.category})`);
  }

  console.log(`\n✅ Seeded ${testMessages.length} test messages`);
}

seedMessages().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/seedAutoArchiveMessages.ts
```

---

## Step 3: Trigger Daily Workflow

### Option A: Call Cloud Function Directly

```bash
# Using Firebase CLI
firebase functions:shell

# In the shell:
> dailyAgentWorkflow({ userId: 'test-creator-123' })
```

### Option B: Use HTTP Trigger (if deployed)

```bash
curl -X POST https://your-region-your-project.cloudfunctions.net/dailyAgentWorkflow \
  -H "Content-Type: application/json" \
  -d '{"userId": "test-creator-123"}'
```

### Option C: Run Script Manually

Create `functions/scripts/triggerAutoArchive.ts`:

```typescript
import * as admin from 'firebase-admin';
import { generateMeaningful10Digest } from '../src/ai/daily-agent-workflow';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

async function triggerWorkflow() {
  const userId = 'test-creator-123';

  console.log('🚀 Triggering daily workflow for:', userId);
  console.log('⏳ Processing...\n');

  const result = await generateMeaningful10Digest({
    userId,
    executionId: `manual-test-${Date.now()}`,
    timestamp: admin.firestore.Timestamp.now()
  } as any);

  console.log('\n✅ Workflow complete!');
  console.log('\n📊 Results:');
  console.log('─────────────────────────────────────');
  console.log('High Priority:', result.meaningful10.highPriority.length);
  console.log('Medium Priority:', result.meaningful10.mediumPriority.length);
  console.log('Auto-Handled:');
  console.log('  - FAQ Responses:', result.meaningful10.autoHandled.faqCount);
  console.log('  - Archived:', result.meaningful10.autoHandled.archivedCount);
  console.log('  - Boundary Sent:', result.meaningful10.autoHandled.boundaryMessageSent);
  console.log('─────────────────────────────────────');
}

triggerWorkflow().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/triggerAutoArchive.ts
```

---

## Step 4: Verify Auto-Archive Results

### 4.1 Check Firestore Console

1. **Conversations Collection** - Check `isArchived` field:
   ```
   conversations/test-conv-4 → isArchived: true
   conversations/test-conv-5 → isArchived: true
   ...etc
   ```

2. **Undo Archive Collection** - Verify undo records created:
   ```
   undo_archive/{undoId} → {
     userId: "test-creator-123",
     conversationId: "test-conv-4",
     archivedAt: Timestamp,
     expiresAt: Timestamp (24 hours later),
     boundaryMessageSent: true,
     canUndo: true
   }
   ```

3. **Rate Limits Collection** - Check boundary rate limits:
   ```
   rate_limits/boundary_messages/limits/{creatorId}_{fanId} → {
     fanId: "fan-4",
     creatorId: "test-creator-123",
     lastBoundarySent: Timestamp,
     expiresAt: Timestamp (7 days later)
   }
   ```

### 4.2 Using Query Script

Create `functions/scripts/verifyAutoArchive.ts`:

```typescript
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function verifyResults() {
  const userId = 'test-creator-123';

  console.log('🔍 Verification Report\n');

  // Count archived conversations
  const archivedSnapshot = await db.collection('conversations')
    .where('participantIds', 'array-contains', userId)
    .where('isArchived', '==', true)
    .get();

  console.log(`📦 Archived Conversations: ${archivedSnapshot.size}`);
  archivedSnapshot.docs.forEach(doc => {
    console.log(`   - ${doc.id}: "${doc.data().lastMessage}"`);
  });

  // Count undo records
  const undoSnapshot = await db.collection('undo_archive')
    .where('userId', '==', userId)
    .where('canUndo', '==', true)
    .get();

  console.log(`\n🔄 Active Undo Records: ${undoSnapshot.size}`);
  undoSnapshot.docs.forEach(doc => {
    const data = doc.data();
    const expiresAt = data.expiresAt.toDate();
    const timeLeft = Math.round((expiresAt.getTime() - Date.now()) / (1000 * 60 * 60));
    console.log(`   - ${doc.id}: ${timeLeft}h remaining`);
  });

  // Count rate limits
  const rateLimitsSnapshot = await db.collection('rate_limits')
    .doc('boundary_messages')
    .collection('limits')
    .get();

  console.log(`\n⏱️  Boundary Rate Limits: ${rateLimitsSnapshot.size}`);
  rateLimitsSnapshot.docs.forEach(doc => {
    const data = doc.data();
    console.log(`   - ${data.fanId}: Last sent ${data.lastBoundarySent.toDate().toLocaleString()}`);
  });

  // Check safety - verify no business/urgent/VIP archived
  const safetyCheck = await db.collection('conversations')
    .where('participantIds', 'array-contains', userId)
    .where('isArchived', '==', true)
    .get();

  console.log(`\n🛡️  Safety Check:`);
  let safetyViolations = 0;

  for (const conv of safetyCheck.docs) {
    const msgs = await conv.ref.collection('messages').get();
    for (const msg of msgs.docs) {
      const metadata = msg.data().metadata || {};
      if (metadata.category === 'business_opportunity' ||
          metadata.category === 'urgent' ||
          metadata.relationshipContext?.isVIP ||
          (metadata.sentimentScore && metadata.sentimentScore < -0.7)) {
        console.log(`   ❌ VIOLATION: ${conv.id} should NOT be archived!`);
        safetyViolations++;
      }
    }
  }

  if (safetyViolations === 0) {
    console.log(`   ✅ All safety checks passed!`);
  }
}

verifyResults().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/verifyAutoArchive.ts
```

---

## Step 5: Test Undo Functionality

### 5.1 In Mobile App

1. Navigate to **Profile → Archived Messages**
2. You should see list of archived conversations with:
   - Countdown timer (e.g., "23h 45m remaining")
   - Progress bar showing time left
   - "Undo Archive" button

3. Tap **"Undo Archive"** on any conversation
4. Confirm in the alert dialog
5. Verify:
   - Success message: "Conversation has been restored to your inbox"
   - Option to "View Conversation"
   - Conversation removed from archived list

### 5.2 Using Script

Create `functions/scripts/testUndo.ts`:

```typescript
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function testUndo() {
  const userId = 'test-creator-123';

  // Get first undo record
  const undoSnapshot = await db.collection('undo_archive')
    .where('userId', '==', userId)
    .where('canUndo', '==', true)
    .limit(1)
    .get();

  if (undoSnapshot.empty) {
    console.log('❌ No undo records found');
    return;
  }

  const undoDoc = undoSnapshot.docs[0];
  const undoData = undoDoc.data();

  console.log(`🔄 Undoing archive for conversation: ${undoData.conversationId}\n`);

  // 1. Restore conversation
  await db.collection('conversations').doc(undoData.conversationId).update({
    isArchived: false,
    updatedAt: admin.firestore.Timestamp.now()
  });
  console.log('✅ Conversation restored');

  // 2. Mark undo record as used
  await undoDoc.ref.update({
    canUndo: false,
    undoneAt: admin.firestore.Timestamp.now()
  });
  console.log('✅ Undo record marked as used');

  // 3. Remove boundary message (if sent)
  if (undoData.boundaryMessageSent) {
    const messagesSnapshot = await db.collection('conversations')
      .doc(undoData.conversationId)
      .collection('messages')
      .where('metadata.isAutoBoundary', '==', true)
      .get();

    for (const msgDoc of messagesSnapshot.docs) {
      await msgDoc.ref.delete();
    }
    console.log('✅ Boundary message removed');
  }

  console.log('\n✅ Undo complete!');
}

testUndo().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/testUndo.ts
```

---

## Step 6: Test Expiry (24-Hour Window)

### Option A: Wait 24 Hours 😴

(Not recommended for testing)

### Option B: Manually Expire Records

Create `functions/scripts/testExpiry.ts`:

```typescript
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function simulateExpiry() {
  const userId = 'test-creator-123';

  // Set expiresAt to past time
  const undoSnapshot = await db.collection('undo_archive')
    .where('userId', '==', userId)
    .get();

  const pastTime = admin.firestore.Timestamp.fromMillis(Date.now() - 25 * 60 * 60 * 1000); // 25 hours ago

  for (const doc of undoSnapshot.docs) {
    await doc.ref.update({
      expiresAt: pastTime,
      canUndo: false
    });
    console.log(`⏰ Expired: ${doc.id}`);
  }

  console.log('\n✅ All undo records expired');
  console.log('🧪 Now test the UI - "Undo" buttons should be disabled');
}

simulateExpiry().catch(console.error);
```

Run:
```bash
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/testExpiry.ts
```

Then verify in app:
- Navigate to **Profile → Archived Messages**
- Undo buttons should show "Expired" and be disabled
- Timer should show "0h 0m"

---

## Step 7: Test Rate Limiting

### Test: Prevent Multiple Boundaries to Same Fan

1. Run workflow again (without clearing rate limits):
   ```bash
   GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/triggerAutoArchive.ts
   ```

2. Verify:
   - Messages still archived
   - NO new boundary messages sent (rate limited)
   - `rateLimited` count increased in results

### Clear Rate Limits (for retesting):

```typescript
// functions/scripts/clearRateLimits.ts
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function clearRateLimits() {
  const snapshot = await db.collection('rate_limits')
    .doc('boundary_messages')
    .collection('limits')
    .get();

  for (const doc of snapshot.docs) {
    await doc.ref.delete();
    console.log(`🗑️  Deleted: ${doc.id}`);
  }

  console.log(`✅ Cleared ${snapshot.size} rate limits`);
}

clearRateLimits().catch(console.error);
```

---

## Expected Test Results

### ✅ Success Criteria

- [ ] **Capacity Respected**: Only 3 messages kept (dailyLimit: 3)
- [ ] **Low Priority Archived**: 7+ fan engagement messages archived
- [ ] **Safety Checks**: Business/Urgent/VIP/Crisis messages NOT archived
- [ ] **Boundary Messages**: Sent to archived fans (max 1/week each)
- [ ] **Undo Records**: Created with 24-hour expiry
- [ ] **Undo Works**: Can restore conversation within 24 hours
- [ ] **Undo Expires**: Cannot undo after 24 hours
- [ ] **Rate Limiting**: Second boundary to same fan blocked within 7 days
- [ ] **UI Display**: Archived messages screen shows countdown timers
- [ ] **UI Functionality**: Undo button works, disabled when expired

### 🐛 Common Issues

**Issue**: No messages archived
- Check: `autoArchiveEnabled: true` in user settings
- Check: Daily limit < total messages count

**Issue**: Business messages archived (safety violation!)
- Check: Message metadata has correct `category: 'business_opportunity'`
- Check: `shouldNotArchive()` function logic

**Issue**: Undo doesn't work
- Check: `canUndo: true` in undo record
- Check: `expiresAt` is in the future
- Check: User ID matches

**Issue**: No boundary messages sent
- Check: Quiet hours settings (messages sent outside quiet hours)
- Check: Rate limit records (max 1/fan/week)

---

## Cleanup After Testing

```bash
# Delete test data
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/cleanupTestData.ts
```

```typescript
// functions/scripts/cleanupTestData.ts
import * as admin from 'firebase-admin';

admin.initializeApp({
  credential: admin.credential.cert(require('../../serviceAccountKey.json'))
});

const db = admin.firestore();

async function cleanup() {
  const userId = 'test-creator-123';

  // Delete conversations
  const convs = await db.collection('conversations')
    .where('participantIds', 'array-contains', userId)
    .get();

  for (const conv of convs.docs) {
    // Delete messages subcollection
    const msgs = await conv.ref.collection('messages').get();
    for (const msg of msgs.docs) {
      await msg.ref.delete();
    }
    await conv.ref.delete();
  }
  console.log(`🗑️  Deleted ${convs.size} conversations`);

  // Delete undo records
  const undos = await db.collection('undo_archive')
    .where('userId', '==', userId)
    .get();

  for (const undo of undos.docs) {
    await undo.ref.delete();
  }
  console.log(`🗑️  Deleted ${undos.size} undo records`);

  // Delete rate limits
  const limits = await db.collection('rate_limits')
    .doc('boundary_messages')
    .collection('limits')
    .get();

  for (const limit of limits.docs) {
    await limit.ref.delete();
  }
  console.log(`🗑️  Deleted ${limits.size} rate limits`);

  console.log('\n✅ Cleanup complete!');
}

cleanup().catch(console.error);
```

---

## Quick Test (All-in-One)

Run all tests in sequence:

```bash
# 1. Setup
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/setupTestUser.ts

# 2. Seed messages
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/seedAutoArchiveMessages.ts

# 3. Trigger workflow
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/triggerAutoArchive.ts

# 4. Verify results
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/verifyAutoArchive.ts

# 5. Test undo
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/testUndo.ts

# 6. Cleanup
GOOGLE_APPLICATION_CREDENTIALS=serviceAccountKey.json npx ts-node functions/scripts/cleanupTestData.ts
```

---

## Next Steps

After manual testing succeeds:
1. ✅ Mark Story 6.4 as **QA Passed**
2. 🚀 Deploy to staging environment
3. 📊 Monitor metrics in production
4. 🎯 Move to Story 6.5 (Settings UI) or 6.6 (Analytics Dashboard)
